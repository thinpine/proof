# -*- coding: utf-8 -*-
"""lvsh-matrix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13zZ1XF1uiV08CbGTKi6dsF11bPP9yW5m
"""

import math
from typing import List, Tuple

def levenshtein_matrix(s1: str, s2: str) -> Tuple[int, List[List[int]]]:
    """
    Calculates the Levenshtein distance matrix and the final distance.

    Returns: (distance, matrix)
    """
    len_s1 = len(s1)
    len_s2 = len(s2)

    # Initialize a matrix for dynamic programming.
    # Size is (len_s1 + 1) x (len_s2 + 1)
    dp: List[List[int]] = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]

    # --- Initialization ---
    # The first row (dp[0][j]) represents the cost of changing an empty string
    # (prefix of s1) into a prefix of s2 (j characters). This is j insertions.
    for j in range(len_s2 + 1):
        dp[0][j] = j

    # The first column (dp[i][0]) represents the cost of changing a prefix of s1
    # (i characters) into an empty string (prefix of s2). This is i deletions.
    for i in range(len_s1 + 1):
        dp[i][0] = i

    # --- Filling the Matrix ---
    for i in range(1, len_s1 + 1):
        for j in range(1, len_s2 + 1):

            # Determine the substitution cost for the current characters
            # s1[i-1] is the character in the first string (A)
            # s2[j-1] is the character in the second string (B)
            cost_sub = 0 if s1[i - 1] == s2[j - 1] else 1

            # The value dp[i][j] is the minimum cost to transform s1[:i] to s2[:j]
            # It is the minimum of three paths:

            # 1. Deletion (from s1): dp[i-1][j] + 1
            #    (Cost to transform s1[:i-1] to s2[:j], then delete s1[i-1])
            deletion_cost = dp[i - 1][j] + 1

            # 2. Insertion (into s1 to match s2): dp[i][j-1] + 1
            #    (Cost to transform s1[:i] to s2[:j-1], then insert s2[j-1])
            insertion_cost = dp[i][j - 1] + 1

            # 3. Substitution or Match: dp[i-1][j-1] + cost_sub
            #    (Cost to transform s1[:i-1] to s2[:j-1], then substitute/match the last character)
            substitution_cost = dp[i - 1][j - 1] + cost_sub

            dp[i][j] = min(deletion_cost, insertion_cost, substitution_cost)

    return dp[len_s1][len_s2], dp

def display_matrix(s1: str, s2: str, dp: List[List[int]]):
    """Prints the Levenshtein distance matrix in a formatted, readable way."""

    # Header row (with s2 characters)
    header = "  " + " " * len(str(max(max(row) for row in dp))) + " | ∅ " + " | ".join(f" {c} " for c in s2)
    print(header)
    print("-" * len(header))

    # Data rows
    for i in range(len(dp)):
        row_label = "∅" if i == 0 else s1[i - 1]

        # Determine the cell width based on the maximum distance value
        cell_width = len(str(max(max(row) for row in dp)))

        row_str = f"{row_label:<2}"

        for j in range(len(dp[0])):
            # Format each cell content
            content = str(dp[i][j])
            row_str += f"| {content:^{cell_width}} "

        print(row_str)

def explain_cell(s1: str, s2: str, dp: List[List[int]], i: int, j: int):
    """Provides a detailed, step-by-step explanation for a chosen cell (i, j)."""

    if i == 0 and j == 0:
        print("\n--- Cell (0, 0) Explanation ---")
        print("This is the starting point. The distance between two empty strings (prefixes of length 0) is 0.")
        return

    if i == 0:
        print(f"\n--- Cell (0, {j}) Explanation ---")
        print(f"The cell represents the distance from an empty string (prefix of '{s1}') to the prefix '{s2[:j]}' ('{s2[j-1]}').")
        print(f"The only way to achieve this is by {j} insertions: D({s1[:i]}, {s2[:j-1]}) + 1.")
        print(f"Cost = D(∅, '{s2[:j-1]}') + 1 (Insertion) = {dp[i][j-1]} + 1 = {dp[i][j]}.")
        return

    if j == 0:
        print(f"\n--- Cell ({i}, 0) Explanation ---")
        print(f"The cell represents the distance from the prefix '{s1[:i]}' ('{s1[i-1]}') to an empty string (prefix of '{s2}').")
        print(f"The only way to achieve this is by {i} deletions: D({s1[:i-1]}, {s2[:j]}) + 1.")
        print(f"Cost = D('{s1[:i-1]}', ∅) + 1 (Deletion) = {dp[i-1][j]} + 1 = {dp[i][j]}.")
        return

    # Standard internal cell calculation
    char_s1 = s1[i - 1]
    char_s2 = s2[j - 1]

    # Calculate costs from previous cells
    cost_sub = 0 if char_s1 == char_s2 else 1

    deletion_val = dp[i - 1][j] + 1
    insertion_val = dp[i][j - 1] + 1
    substitution_val = dp[i - 1][j - 1] + cost_sub

    final_cost = dp[i][j]

    print(f"\n--- Cell ({i}, {j}) Explanation: Transform '{s1[:i]}' to '{s2[:j]}' ---")
    print(f"This cell compares character A='{char_s1}' (from '{s1}') and character B='{char_s2}' (from '{s2}').")
    print("The final cost is the minimum of three possibilities (paths to this cell):")
    print("-" * 50)

    # 1. Deletion Path
    print(f"1. DELETE '{char_s1}' from A (Down):")
    print(f"   Cost: D('{s1[:i-1]}' to '{s2[:j]}') + 1 (Deletion) = {dp[i - 1][j]} + 1 = {deletion_val}")

    # 2. Insertion Path
    print(f"2. INSERT '{char_s2}' into A (Right):")
    print(f"   Cost: D('{s1[:i]}' to '{s2[:j-1]}') + 1 (Insertion) = {dp[i][j - 1]} + 1 = {insertion_val}")

    # 3. Substitution/Match Path
    operation = "MATCH" if cost_sub == 0 else "SUBSTITUTE"
    print(f"3. {operation} '{char_s1}' for '{char_s2}' (Diagonal):")
    print(f"   Cost: D('{s1[:i-1]}' to '{s2[:j-1]}') + {cost_sub} ({operation} Cost) = {dp[i - 1][j - 1]} + {cost_sub} = {substitution_val}")

    print("-" * 50)
    print(f"Final D('{s1[:i]}', '{s2[:j]}') = min({deletion_val}, {insertion_val}, {substitution_val}) = {final_cost}")

    # Identify which operation resulted in the minimum cost
    min_val = min(deletion_val, insertion_val, substitution_val)
    paths = []
    if min_val == deletion_val:
        paths.append("Deletion")
    if min_val == insertion_val:
        paths.append("Insertion")
    if min_val == substitution_val:
        paths.append("Substitution/Match")

    print(f"The minimum distance of {final_cost} was achieved via: {', '.join(paths)}.")


def main():
    """Main function for user interaction and demonstration."""
    print("--- Levenshtein Distance Matrix Explainer ---")
    print("This tool calculates the distance between two strings and shows you the step-by-step logic for any cell in the calculation table.")

    try:
        # Get two strings from the user
        s1 = input("\nEnter the first string (A): ").strip().lower()
        s2 = input("Enter the second string (B): ").strip().lower()

        if not s1 or not s2:
             print("\nError: Both strings must contain at least one character.")
             return

        # Calculate distance and the full matrix
        distance, dp_matrix = levenshtein_matrix(s1, s2)

        print("\n" + "=" * 50)
        print(f"STRINGS: A='{s1}' (Rows) and B='{s2}' (Columns)")
        print(f"Final Levenshtein Distance D(A, B) = {distance}")
        print("=" * 50)

        print("\n--- Levenshtein Distance Matrix (DP Table) ---")
        display_matrix(s1, s2, dp_matrix)

        while True:
            print("\n--- Interactive Cell Explanation ---")
            print(f"Enter the row and column index (e.g., '1,2') for detailed explanation.")
            print(f"Indices go from 0 up to Row Max ({len(s1)}) and Column Max ({len(s2)}).")
            print("Type 'q' to quit.")

            user_input = input("Row, Column: ").strip()

            if user_input.lower() == 'q':
                break

            try:
                # Parse user input for row and column indices
                parts = [int(p.strip()) for p in user_input.split(',')]
                if len(parts) != 2:
                    raise ValueError("Input format must be 'row, column'.")

                i, j = parts

                # Validate indices
                if not (0 <= i <= len(s1) and 0 <= j <= len(s2)):
                    print(f"Error: Indices must be between (0, 0) and ({len(s1)}, {len(s2)}). Please try again.")
                    continue

                # Call the explanation function
                explain_cell(s1, s2, dp_matrix, i, j)

            except ValueError as ve:
                print(f"Invalid input: {ve}. Please enter valid integer indices separated by a comma (e.g., 2,3).")
            except Exception as e:
                print(f"An unexpected error occurred: {e}")

    except Exception as e:
        print(f"\nAn error occurred: {e}")

if __name__ == "__main__":
    main()